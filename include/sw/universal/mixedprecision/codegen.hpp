#pragma once
// codegen.hpp: mixed-precision code generator for POP precision tuning
//
// Copyright (C) 2017 Stillwater Supercomputing, Inc.
// SPDX-License-Identifier: MIT
//
// This file is part of the universal numbers project.
//
// Generates mixed-precision C++ code using Universal types based on
// POP analysis results. The output follows the format established by
// PrecisionConfigGenerator::generateConfigHeader().
//
// Reference: Dorra Ben Khalifa, "Fast and Efficient Bit-Level Precision Tuning,"
//            PhD thesis, Universite de Perpignan, 2021.

#include <universal/mixedprecision/expression_graph.hpp>
#include <universal/utility/type_advisor.hpp>
#include <string>
#include <sstream>
#include <iomanip>
#include <vector>

namespace sw { namespace universal {

class PopCodeGenerator {
public:
	explicit PopCodeGenerator(const ExprGraph& graph, const TypeAdvisor& advisor = TypeAdvisor())
		: graph_(graph), advisor_(advisor) {}

	// Generate a C++ header with type aliases for each variable
	std::string generateHeader(const std::string& guard_name = "POP_PRECISION_CONFIG_HPP") const {
		std::ostringstream ss;

		ss << "#pragma once\n";
		ss << "// Auto-generated mixed-precision configuration from POP analysis\n";
		ss << "//\n";
		ss << "// Generated by Universal Numbers Library POP Precision Tuning\n";
		ss << "// https://github.com/stillwater-sc/universal\n";
		ss << "//\n";
		ss << "// This header defines type aliases for each variable based on\n";
		ss << "// static precision analysis (minimum bits needed for accuracy).\n\n";

		ss << "#ifndef " << guard_name << "\n";
		ss << "#define " << guard_name << "\n\n";

		// Collect variable and intermediate type recommendations
		for (const auto& node : graph_.nodes()) {
			if (node.op == OpKind::Constant) continue;

			auto rec = advisor_.recommendForNsb(node.nsb_final, node.lo, node.hi);
			ss << "// " << node.name << ": " << node.nsb_final
			   << " significant bits, range [" << node.lo << ", " << node.hi << "]\n";
			ss << "using type_" << sanitize_name(node.name) << " = "
			   << universal_type_string(rec, node.nsb_final) << ";\n\n";
		}

		ss << "#endif // " << guard_name << "\n";
		return ss.str();
	}

	// Generate an analysis summary as a comment block
	std::string generateReport() const {
		std::ostringstream ss;

		ss << "/*\n";
		ss << " * POP Precision Analysis Report\n";
		ss << " * " << std::string(40, '=') << "\n";
		ss << " *\n";

		double total_bits = 0;
		double fp64_total = 0;

		for (const auto& node : graph_.nodes()) {
			auto rec = advisor_.recommendForNsb(node.nsb_final, node.lo, node.hi);
			ss << " * " << std::left << std::setw(12) << node.name
			   << " nsb=" << std::setw(4) << node.nsb_final
			   << " -> " << rec.type.name << "\n";
			total_bits += rec.type.total_bits;
			fp64_total += 64;
		}

		double savings = (1.0 - total_bits / fp64_total) * 100.0;
		ss << " *\n";
		ss << " * Total bits: " << total_bits << " (vs " << fp64_total << " fp64)\n";
		ss << " * Bit savings: " << std::fixed << std::setprecision(1) << savings << "%\n";
		ss << " */\n";

		return ss.str();
	}

	// Generate a code template that uses the precision config
	std::string generateExampleCode(const std::string& function_name = "compute") const {
		std::ostringstream ss;

		ss << "#include \"pop_precision_config.hpp\"\n";
		ss << "#include <universal/number/cfloat/cfloat.hpp>\n";
		ss << "#include <universal/number/posit/posit.hpp>\n";
		ss << "#include <universal/number/fixpnt/fixpnt.hpp>\n\n";

		ss << "using namespace sw::universal;\n\n";

		// Collect variables (inputs)
		std::vector<const ExprNode*> inputs;
		for (const auto& node : graph_.nodes()) {
			if (node.op == OpKind::Variable) {
				inputs.push_back(&node);
			}
		}

		// Function signature
		ss << "auto " << function_name << "(";
		for (size_t i = 0; i < inputs.size(); ++i) {
			if (i > 0) ss << ", ";
			ss << "type_" << sanitize_name(inputs[i]->name) << " " << inputs[i]->name;
		}
		ss << ") {\n";

		// Find the output (last node with a requirement, or just the last node)
		int output_id = -1;
		for (const auto& node : graph_.nodes()) {
			if (node.nsb_required >= 0) output_id = node.id;
		}
		if (output_id < 0 && !graph_.nodes().empty()) {
			output_id = graph_.nodes().back().id;
		}

		// Generate computation body (pseudo-code for non-input nodes)
		for (const auto& node : graph_.nodes()) {
			if (node.op == OpKind::Constant || node.op == OpKind::Variable) continue;

			ss << "    type_" << sanitize_name(node.name) << " " << node.name << " = ";

			auto lhs_name = [&]() -> std::string {
				if (node.lhs >= 0) return graph_.nodes()[static_cast<size_t>(node.lhs)].name;
				return "?";
			};
			auto rhs_name = [&]() -> std::string {
				if (node.rhs >= 0) return graph_.nodes()[static_cast<size_t>(node.rhs)].name;
				return "?";
			};

			switch (node.op) {
			case OpKind::Add:  ss << lhs_name() << " + " << rhs_name(); break;
			case OpKind::Sub:  ss << lhs_name() << " - " << rhs_name(); break;
			case OpKind::Mul:  ss << lhs_name() << " * " << rhs_name(); break;
			case OpKind::Div:  ss << lhs_name() << " / " << rhs_name(); break;
			case OpKind::Neg:  ss << "-" << lhs_name(); break;
			case OpKind::Abs:  ss << "abs(" << lhs_name() << ")"; break;
			case OpKind::Sqrt: ss << "sqrt(" << lhs_name() << ")"; break;
			default:           ss << "/* unknown */"; break;
			}

			ss << ";\n";
		}

		if (output_id >= 0) {
			ss << "    return " << graph_.nodes()[static_cast<size_t>(output_id)].name << ";\n";
		}

		ss << "}\n";
		return ss.str();
	}

private:
	const ExprGraph& graph_;
	TypeAdvisor advisor_;

	static std::string sanitize_name(const std::string& name) {
		std::string result;
		for (char c : name) {
			if (std::isalnum(static_cast<unsigned char>(c)) || c == '_') {
				result += c;
			} else {
				result += '_';
			}
		}
		return result;
	}

	// Generate a Universal type string from recommendation
	static std::string universal_type_string(const TypeRecommendation& rec, int nsb) {
		// Extract the concrete type from the recommendation name
		// If it has a parenthetical like "half (cfloat<16,5>)", extract the cfloat part
		const std::string& name = rec.type.name;
		auto paren = name.find('(');
		if (paren != std::string::npos) {
			auto end_paren = name.find(')');
			if (end_paren != std::string::npos) {
				std::string inner = name.substr(paren + 1, end_paren - paren - 1);
				return "sw::universal::" + inner;
			}
		}

		// If name already starts with a type family, prefix with namespace
		if (name.find("posit") == 0 || name.find("cfloat") == 0 ||
		    name.find("fixpnt") == 0 || name.find("lns") == 0) {
			return "sw::universal::" + name;
		}

		// Fallback: generate cfloat with appropriate bits
		int total_bits = std::max(8, ((nsb + 8) / 8) * 8); // round up to byte boundary
		int exp_bits = (total_bits <= 16) ? 5 : (total_bits <= 32) ? 8 : 11;
		(void)total_bits;
		return "sw::universal::cfloat<" + std::to_string(rec.type.total_bits) + "," +
		       std::to_string(exp_bits) + ">";
	}
};

}} // namespace sw::universal
